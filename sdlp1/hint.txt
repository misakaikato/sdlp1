->用于访问指针指向的对象/结构体的成员
.直接访问对象/结构体的成员
::一般用于内部访问和定义，如 类名::成员{定义} 或 std::cout（具体为什么这么做还不甚理解，似乎和命名空间有关

SDL_ConvertSurface(loadedSurface, gScreenSurface->format, NULL)
当你加载一个BMP图像时，通常它都是24位色格式。而现代显示器不支持24位色，所以SDL会在每次刷新时都把它转换为32位色。这就造成了不必要的资源浪费，所以在这里用这句代码把图像在内存中转换为屏幕用的格式（使用了屏幕苏菲的成员变量，所以不管它是多少位都一样）

SDL的缩放方法SDL_BlitScaled()所操作的苏菲指针必须是经过上面那句代码格式化操作过的苏菲，至少软件渲染模式下如此

因为教程一开始写的是靠SURFACE渲染，后来改成了TEXTURE渲染，浪费了一些代码
本来觉得应该实现SURFACE和TEXTURE都能画出来，不过第一已经删了SURFACE的代码，第二也没什么卵用，所以只实现TEXTURE渲染。如果有需要的话，再照着教程的早期内容再写一个。

你可以使用DrawRect FillRect DrawLine和DrawPoint在屏幕上画东西
本质上和JAVA课本上那套一样，你需要不断的变换渲染器颜色，所以挺鸡肋的，教程的这段就跳过了，是第八章

你可以使用RenderSetViewport方法在同一个循环中把不同的图片渲染到屏幕，不过怎么看也会有更简单的办法来渲染尺寸正确的图片，所以这个方法大概没什么卵用

你可以使用如下方法
SDL_SetColorKey( loadedSurface, SDL_TRUE, SDL_MapRGB( loadedSurface->format, 0, 0xFF, 0xFF ) );
来设置一个SURFACE的过滤色，比如大部分MUGEN游戏的背景都是紫色。经过过滤色的SURFACE转换成TEXTURE的时候就会变透明色。
如果有此需求，应改造XML文件结构，改造资源管理器类的INIT方法以获取信息，给LoadTexture加入新参数，然后将上述代码加入它的两个调用方法的其中之一，也就是写在载入SURFACE后面。
不过鉴于基本都在用PNG，所以这个功能大概是不需要

vector list deque 三种不同的智能数组各有优势。
vector是连续的储存空间，所以寻址极快，而缺点是不适合增删元素，增删需要整个复制然后重组。
list是离散空间存储，每个变量都包含一个指向它前面一个变量的指针，然而代价是寻址很慢，但从前面或从后面删除/插入元素都极快
deque综合了两个的优势，但都要稍微慢一些，它的每个变量都分别包含一个指向上一个元素和下一个元素的指针，所以也叫双向队列。不过泛用性很高。deque的最大缺点就是不擅长中间的插入/删除

你可以使用SDL_SetTextureColorMod( mTexture, red, green, blue ); 方法来给贴图设置一个颜色的正片叠底，英文是multiply，即“乘”。可以想象为给贴图蒙上一层彩色玻璃板。
关于SDL如何实现更多的混合模式，需要更多的研究才行

SDL的事件中有一个state变量，可能能用来解决按住延迟问题

左摇杆X = 0 左摇杆Y = 1  LT = 2  右摇杆X = 3 右摇杆Y = 4  RT = 5
中间0 上1 右2 右上3 下4 上下5 右下6 上下右7 左8 左上9 左右10 左右上11 左下12 上下左13 左右下14 全按15
X○□△ LB RB SELECT START 左摇杆 右摇杆
方向键其实就是2N数列
